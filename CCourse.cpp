// Class automatically generated by Dev-C++ New Class wizard

#include "CCourse.h" // class's header file
#include <wx/tokenzr.h>
#include <wx/regex.h>
#include "Utils.h"
#include "CLeg.h"

// class constructor
CCourse::CCourse(wxString& a_Data)
    {
	if (!ValidData(a_Data))
		return;
		
	wxStringTokenizer tokens(a_Data, "=", wxTOKEN_RET_EMPTY_ALL);
	if (tokens.CountTokens() < 3 || tokens.CountTokens() > 4)
		return;
		
	m_Name = tokens.GetNextToken();  // course name can be anything
	wxString temp = tokens.GetNextToken();
	wxStringTokenizer controls(temp, ",", wxTOKEN_RET_EMPTY_ALL);
	long lastCN(-1);
	long nextCN;
    while (controls.CountTokens() > 0)
        {            
        nextCN = ToLong(controls.GetNextToken());
        m_Controls.push_back(new CLeg(lastCN, nextCN));
        lastCN = nextCN;	
        }
    m_Controls.push_back(new CLeg(lastCN, -2));
		
	m_Length = tokens.GetNextToken();
	m_Climb = tokens.GetNextToken();		
    }

// class destructor
CCourse::~CCourse()
    {
        
    }

bool CCourse::ValidData(wxString& a_Data)
    {
// Course data is delimted by '=' signs	
// First part is course name, then comma separated list of control codes, distance, climb
// Climb is optional
	wxStringTokenizer tokens(a_Data, "=", wxTOKEN_RET_EMPTY_ALL);
	if (tokens.CountTokens() < 3 || tokens.CountTokens() > 4)
		return false;
		
	tokens.GetNextToken();  // course name can be anything
	wxString temp = tokens.GetNextToken();
	wxStringTokenizer controls(temp, ",", wxTOKEN_RET_EMPTY_ALL);
	wxRegEx reControl("[0-9]+");
	while (controls.CountTokens() > 0)
		{
		if (!reControl.Matches(controls.GetNextToken()))
			{	
			return false;
			}
		}
		
	wxRegEx reLength("[0-9]+\\.?[0-9]*");
	if (!reControl.Matches(tokens.GetNextToken()))
		return false;
		
	if(tokens.CountTokens() > 0)
		{
		wxRegEx reClimb("[0-9]+");	
		if (!reClimb.Matches(tokens.GetNextToken()))
			return false;	
		}
	return true;
    }


void CCourse::SetOptionalLeg(int a_Index)
    {
    if (a_Index >  (int) m_Controls.size())
        {
        wxString s;
        s.Printf("Cannot make leg %d optional, course only has %d legs", a_Index, m_Controls.size());
        SIMessageBox(s, "SI Simple", wxOK|wxCENTRE|wxICON_EXCLAMATION);
        return;
        }        
        
    CLeg* leg = m_Controls[a_Index];
    if (leg->GetUntimed())
        {
        wxString s;
        s.Printf("Cannot make leg %d optional, it is an \"untimed\" leg", a_Index);
        SIMessageBox(s, "SI Simple", wxOK|wxCENTRE|wxICON_ERROR);
        return;
        }
    
    leg->SetOptional(true);
    }
    
bool CCourse::GetOptionalLeg(int a_Index)
    {
    if (a_Index > (int) m_Controls.size())
        return false;

    return m_Controls[a_Index]->GetOptional();
    }    
    
void CCourse::SetUntimedLeg(int a_Index)
    {
    if (a_Index > (long) m_Controls.size())
        {
        wxString s;
        s.Printf("Cannot make leg %d untimed, course only has %ld legs", a_Index, (long)m_Controls.size());
        SIMessageBox(s, "SI Simple", wxOK|wxCENTRE|wxICON_EXCLAMATION);
        return;
        }
    CLeg* leg = m_Controls[a_Index];
                     
    if (leg->GetOptional())
        {
        wxString s;
        s.Printf("Cannot make leg %d untimed, it is optional on this course", a_Index);
        SIMessageBox(s, "SI Simple", wxOK|wxCENTRE|wxICON_EXCLAMATION);
        return;
        }
        
    leg->SetUntimed(true);                 
    }

bool CCourse::GetUntimedLeg(int a_Index)
    {
    if (a_Index > (int) m_Controls.size())
        return false;

    return m_Controls[a_Index]->GetUntimed();
    } 

void CCourse::CompulsoryControls(std::list<long>& a_Controls)
    {
    for (unsigned int i = 0; i < m_Controls.size() - 1; i++) // skip finish leg
        if (!m_Controls[i]->GetOptional())
            a_Controls.push_back(m_Controls[i]->GetEndCN());
    }

/*void CCourse::UntimedLegs(std::set<long>& a_Legs)
    {
    a_Controls = m_UntimedControls;
    }*/
CLeg CCourse::GetLeg(int a_Index)
    {
    return *m_Controls[a_Index];
    }

wxString CCourse::TextDescStr()
{
    wxString s;
    if (m_Controls.size() > 1)
        {
        if (!m_Climb.IsEmpty())
            s.Printf("%s Course: %d controls %s km %s m", m_Name.c_str(), m_Controls.size() -1, m_Length.c_str(), m_Climb.c_str());
        else
            s.Printf("%s Course: %d controls %s km", m_Name.c_str(), m_Controls.size() -1, m_Length.c_str());
        }
    else
        s.Printf("%s Course: %s km", m_Name.c_str(), m_Length.c_str());
    return s;                        
}

wxString CCourse::TextSplitHdrStr()
{
    wxString result("  # Name                         Result   Start   ");
    wxString s;
    for (int i = 0; i < (int)m_Controls.size() -1; i++)
        {
        s.Printf(" %2s.(%3s) ", wxString::Format(wxT("%d"),i+1).c_str(), wxString::Format(wxT("%ld"), m_Controls[i]->GetEndCN()).c_str());
        result += s;
        }
    result += "  Finish.           min/km";
    return result;    
}
