// Class automatically generated by Dev-C++ New Class wizard

#include "cresult.h" // class's header file
#include <wx/tokenzr.h>
#include <wx/arrstr.h>
#include "CSiDetails.h"
#include "CEvent.h"
#include "Utils.h"
#include "CCourse.h"
#include "CLegStat.h"

// class constructor
CResult::CResult(wxString& a_RawData) : m_RawData(a_RawData), m_ProcessedResult(false),
	m_Invalid(false), m_Finished(true), m_Pos(0), m_FinishedOverride(false), m_FinishedOverrideSet(false),
	m_Course(NULL)
	{
	wxStringTokenizer tokens(m_RawData, ",", wxTOKEN_RET_EMPTY_ALL);
	wxArrayString array;
	for (unsigned int i = 0; tokens.CountTokens() > 0; i++)
		array.Add(tokens.GetNextToken());


	array[0].ToLong(&m_RawIndex);
	array[2].ToLong(&m_SINumber);

	CSiDetails* detail;
	if ((detail = CEvent::Event()->GetSIData(m_SINumber)) != NULL)
		{
		m_Name = detail->GetName();
		m_Club = detail->GetClub();
		}

	if (!array[5].IsEmpty() && m_Name.IsEmpty())
		m_Name = array[5] + ' ' + array[6];

	if (!array[7].IsEmpty() && m_Club.IsEmpty())
		m_Club = array[7].Left(3);

	m_Clear.SetData(ToLong(array[16]), array[17], ToDateTime(array[18]));
	m_Check.SetData(ToLong(array[19]), array[20], ToDateTime(array[21]));
	m_Start.SetData(ToLong(array[22]), array[23], ToDateTime(array[24]));
	m_Finish.SetData(ToLong(array[25]), array[26], ToDateTime(array[27]));

	// Now try to find all the punch data
	unsigned long punches = ToLong(array[28]);
	for (unsigned long i = 0; i < punches; i++)
		m_Punches.push_back(new CPunch(ToLong(array[(i*3)+29]), array[(i*3)+30], ToDateTime(array[(i*3)+31])));

	DoTimeSanityCheck();
	}

// class destructor
CResult::~CResult()
	{
	for (std::list<CPunch*>::iterator i = m_Punches.begin(); i != m_Punches.end(); i++)
		delete (*i);

	ClearLegStats();
	}

bool CResult::ValidData(wxString& a_Data)
	{
	wxStringTokenizer tokens(a_Data, ",", wxTOKEN_RET_EMPTY_ALL);
	if (tokens.CountTokens() < 28)
		return false;

	if (tokens.GetNextToken() == "No.") // header record
		return false;

	tokens.GetNextToken(); // download time
	wxString temp = tokens.GetNextToken();
	long val;
	return (temp.ToLong(&val));
	}

void CResult::DoTimeSanityCheck()
	{
	wxDateTime timeMark = m_Start.GetWhen();
	bool timeAdjusted(false);
	bool ignoredPunches(false);

	if (m_Start.GetWhen() == wxInvalidDateTime)
		{
		CEvent::Event()->LogResultProblem(this, "No start time, marked invalid");
		m_Invalid = true;
		}


	for (std::list<CPunch*>::iterator i = m_Punches.begin(); i != m_Punches.end(); i++)
		{
		if ((*i)->GetWhen().IsEarlierThan(timeMark))
			{
			wxDateTime plus6(timeMark);
			wxDateTime plus12(timeMark);
			plus6.Add(wxTimeSpan(6));
			plus12.Add(wxTimeSpan(12));

			// Check for date rollover
			if ((*i)->GetWhen().IsLaterThan(plus6) && (*i)->GetWhen().IsEarlierThan(plus12))
				{
				wxDateTime temp((*i)->GetWhen());
				temp.Add(wxTimeSpan(12));
				(*i)->SetWhen(temp);

				timeAdjusted = true;
				}
			else
				{
				// skip control if last valid control was start ?
				ignoredPunches = true;
				(*i)->SetIgnore(true);
				}
			}
		else
			{
			timeMark = (*i)->GetWhen();
			}
		}

	if (m_Finish.GetWhen() == wxInvalidDateTime)
		{
		CEvent::Event()->LogResultProblem(this, "No finish time, marked invalid");
		m_Invalid = true;
		}
	else
		{
		if (m_Finish.GetWhen().IsEarlierThan(timeMark))
			{
			wxDateTime plus6(timeMark);
			wxDateTime plus12(timeMark);
			plus6.Add(wxTimeSpan(6));
			plus12.Add(wxTimeSpan(12));

			// Check for date rollover
			if (m_Finish.GetWhen().IsLaterThan(plus6) && m_Finish.GetWhen().IsEarlierThan(plus12))
				{
				wxDateTime temp(m_Finish.GetWhen());
				temp.Add(wxTimeSpan(12));
				m_Finish.SetWhen(temp);
				timeAdjusted = true;
				}
			else
				{
				// go backwards and ignore any controls punched after the finish, if that leaves any
				int j(0);
				for (std::list<CPunch*>::iterator i = m_Punches.begin(); i != m_Punches.end(); i++)
					{
					if ((*i)->GetWhen().IsLaterThan(m_Finish.GetWhen()))
						(*i)->SetIgnore(true);
					j++;
					ignoredPunches = true;
					}
				if (j == 0)
					{
					CEvent::Event()->LogResultProblem(this, "Finish time looks too early, marked invalid");
					m_Invalid = true;
					}
				}
			}
		}

	if (timeAdjusted && !m_Invalid)
		CEvent::Event()->LogResultProblem(this, "Adjusted punch time(s) - clock may have rolled over");

	if (ignoredPunches && !m_Invalid)
		CEvent::Event()->LogResultProblem(this, "Ignored some punches - maybe runner didn't clear or or punched after finish");
	}


void CResult::PunchedControls(std::list<CPunch>& a_Controls, bool a_IncludeStartFinish)
	{
	if (a_IncludeStartFinish && m_Start.GetWhen() != wxInvalidDateTime)
		a_Controls.push_back(m_Start);
	for (std::list<CPunch*>::iterator i = m_Punches.begin(); i != m_Punches.end(); i++)
		if (!(*i)->GetIgnore())
			a_Controls.push_back(*(*i));
	if (a_IncludeStartFinish && m_Finish.GetWhen() != wxInvalidDateTime)
		a_Controls.push_back(m_Finish);
	}

wxString CResult::DebugStr()
	{
	wxString s;
	s.Printf("SI: %ld, Clear CN: %ld, Clear Time: %s", m_SINumber, m_Clear.GetCN(), m_Clear.GetWhen().FormatISOTime().c_str());
	return s;
	}

wxTimeSpan CResult::TimeTaken()
	{
	wxTimeSpan result;
	if (m_Invalid || m_Finish.GetWhen() == wxInvalidDateTime || m_Start.GetWhen() == wxInvalidDateTime)
		return result;

	result = m_Finish.GetWhen() - m_Start.GetWhen();

	// Check for any untimed legs
	for (int i = 0; i < m_Course->GetLegCount(); i++)
		if (m_Course->GetUntimedLeg(i) && m_LegStats.find(i) != m_LegStats.end())
			{
			result -= m_LegStats[i]->m_LegTime;
			}
	return result;
	}

wxString CResult::TextResultStr()
	{
	wxString s;
	if (!m_Invalid && GetFinished() && m_Pos > 0)
		s.Printf(" %3s %-26s %3.3s %s", wxString::Format(wxT("%ld"),m_Pos).c_str(), GetName().c_str(), m_Club.c_str(), FormatTimeTaken(TimeTaken()).c_str());
	else
		s.Printf("     %-26s %3.3s DNF", GetName().c_str(), m_Club.c_str());
	return s;
	}

wxString CResult::TextElapsedStr()
	{
	if (m_Invalid)
		return "";

	wxString result, pos;
	if (GetFinished())
		pos = wxString::Format(wxT("%ld"),m_Pos);
	else
		pos = " ";
	result.Printf("%3s %-26.26s %7s  %8s ", pos.c_str(),
	              GetName().c_str(), FormatTimeTaken(TimeTaken()).c_str(), m_Start.GetWhen().FormatTime().c_str());
	wxString s;
	for (int i = 0; i < m_Course->GetLegCount(); i++)
		{
		if (!GetLegStat(i))
			s.Printf("%10.10s"," ");
		else
			/*           if (CEvent::Event()->GetShowHTML() &&
			               GetLegStat(i)->m_ElapsedPos == 1)
			               {
			               s.Printf("<span style=\"color:red\">%7s%3s</span>", FormatTimeTaken(GetLegStat(i)->m_ElapsedTime).c_str(), wxString::Format(wxT("%ld"),GetLegStat(i)->m_ElapsedPos).c_str());
			               }
			              else if (CEvent::Event()->GetShowHTML() &&
			               GetLegStat(i)->m_ElapsedPos == 2 || GetLegStat(i)->m_ElapsedPos == 3)
			               {
			               s.Printf("<span style=\"color:blue\">%7s%3s</span>", FormatTimeTaken(GetLegStat(i)->m_ElapsedTime).c_str(), wxString::Format(wxT("%ld"),GetLegStat(i)->m_ElapsedPos).c_str());
			               }
			               else*/
			s.Printf("%7s%3s", FormatTimeTaken(GetLegStat(i)->m_ElapsedTime).c_str(), wxString::Format(wxT("%ld"),GetLegStat(i)->m_ElapsedPos).c_str());
		result += s;
		}
	if (m_Finished)
		{
		double speed, len;
		m_Course->GetLength().ToDouble(&len);
		speed = TimeTaken().GetSeconds().ToDouble()/ (len * 60);
		s.Printf("   %s   %6.2f",FormatTimeTaken(TimeTaken()).c_str(),speed);
		result += s;
		}
	return result;
	}

wxString CResult::TextLegStr()
	{
	wxString result;
	if (m_Invalid)
		return result;

	result.Printf("%49s", " ");
	wxString s;
	for (int i = 0; i < m_Course->GetLegCount(); i++)
		{

		if (!GetLegStat(i) || GetLegStat(i)->m_LegTime.GetSeconds() == 0)
			s.Printf("%10.10s"," ");
		else
			{
			/*          if (CEvent::Event()->GetShowHTML() &&
			              GetLegStat(i)->m_LegPos == 1)
			              {
			              s.Printf("<span style=\"color:red\">%7s%3s</span>", FormatTimeTaken(GetLegStat(i)->m_LegTime).c_str(),
			                   wxString::Format(wxT("%ld"),GetLegStat(i)->m_LegPos).c_str());
			              }
			          else if (CEvent::Event()->GetShowHTML() &&
			              GetLegStat(i)->m_LegPos == 2 || GetLegStat(i)->m_LegPos == 3)
			              {
			              s.Printf("<span style=\"color:blue\">%7s%3s</span>", FormatTimeTaken(GetLegStat(i)->m_LegTime).c_str(),
			                   wxString::Format(wxT("%ld"),GetLegStat(i)->m_LegPos).c_str());
			              }
			          else   */
			s.Printf("%7s%3s", FormatTimeTaken(GetLegStat(i)->m_LegTime).c_str(),
			         wxString::Format(wxT("%ld"),GetLegStat(i)->m_LegPos).c_str());
			}
		result += s;
		}

	return result;
	}

wxString CResult::TextLegBehindStr()
	{
	wxString result;
	if (m_Invalid)
		return result;

	result.Printf("%49s", " ");
	wxString s;
	for (int i = 0; i < m_Course->GetLegCount(); i++)
		{
		if (!GetLegStat(i) || GetLegStat(i)->m_LegTime.GetSeconds() == 0)
			s.Printf("%10.10s"," ");
		else
			s.Printf("%7s   ", FormatTimeTaken(GetLegStat(i)->m_LegBehind, true).c_str());
		result += s;
		}
	return result;
	}


wxString CResult::RawDataDisplayStr()
	{
	wxString index;
	index.Printf("(%ld)", m_RawIndex);

	wxString punches;
	for (std::list<CPunch*>::iterator i = m_Punches.begin(); i != m_Punches.end(); i++)
		if (!(*i)->GetIgnore())
			{
			wxString s;
			s.Printf("%3.3ld ", (*i)->GetCN());
			punches += s;
			}

	wxString totalTime;
	totalTime = FormatTimeTaken(m_Finish.GetWhen() - m_Start.GetWhen());

	wxString s;
	s.Printf("%5s %-9ld%-26.26s%-11s %c%s %s",
	         index.c_str(),
	         m_SINumber,
	         m_Name.c_str(),
	         m_Course ? m_Course->GetName().c_str() : "[no course]",
	         m_Finished ? '+' : '-',
	         totalTime.c_str(),
	         punches.c_str());
	return s;
	}

bool CResult::GetFinished()
	{
	if (m_FinishedOverrideSet)
		return m_FinishedOverride;
	else
		return m_Finished;
	}

void CResult::SetFinishedOverride(bool a_Finished)
	{
	if (!GetInvalid())
		{
		m_FinishedOverride = a_Finished;
		m_FinishedOverrideSet = true;
		}
	}

void CResult::AddLegStat(CLegStat* a_LegStat)
	{
	m_LegStats[a_LegStat->m_Index] = a_LegStat;
	}

void CResult::ClearLegStats()
	{
	for (std::map<int, CLegStat*>::iterator i = m_LegStats.begin(); i != m_LegStats.end(); i++)
		delete i->second;
	}

CLegStat* CResult::GetLegStat(int a_Leg)
	{
	if (m_LegStats.find(a_Leg) == m_LegStats.end())
		return NULL;
	return m_LegStats[a_Leg];
	}

wxString CResult::GetDisplayName()
	{
	if (m_Name.IsEmpty())
		{
		wxString s;
		s.Printf("(unknown) SI:%ld", m_SINumber);
		return s;
		}
	else
		return m_Name;
	}

void CResult::AddXML(CXmlWriter& a_Writer)
	{
	a_Writer.StartElement("PersonResult");
	a_Writer.StartElement("Person");
	a_Writer.StartElement("PersonName");
	wxString safename(m_Name);
	safename.Replace("&","+");
	wxStringTokenizer name_tokens(safename, wxT(" "));
	std::vector<wxString> names;
	while (name_tokens.HasMoreTokens())
		names.push_back(name_tokens.GetNextToken());

	a_Writer.StartElement("Family");
	if (names.size() == 0)
		a_Writer.AddValue("name");
	else
		a_Writer.AddValue(names[names.size() -1]);
	a_Writer.EndElement();
	for (int i = 0; i < ((int)names.size()) -1; i++)
		{
		a_Writer.StartElement("Given");
		a_Writer.AddValue(names[i]);
		a_Writer.EndElement();
		}
	if (names.size() < 2)
		{
		a_Writer.StartElement("Given");
		if (names.size() == 0)
			a_Writer.AddValue("no");
		else
			a_Writer.AddValue("someone");
		a_Writer.EndElement();
		}
	a_Writer.EndElement(); // PersonName

	a_Writer.StartElement("PersonId");
	a_Writer.AddValue(PersonID());
	a_Writer.EndElement();
	a_Writer.EndElement(); //Person

	a_Writer.StartElement("Club");
	a_Writer.StartElement("ClubId");
	a_Writer.AddValue(ClubID());
	a_Writer.EndElement();
	a_Writer.StartElement("ShortName");
	a_Writer.AddValue(ClubID());
	a_Writer.EndElement();
	a_Writer.StartElement("CountryId", "value=\"other\"");
	a_Writer.EndElement();
	a_Writer.EndElement();

	a_Writer.StartElement("Result");
	if (!TimeTaken().IsNull())
		{
		a_Writer.StartElement("Time");
		a_Writer.AddValue(FormatTimeTaken(TimeTaken(),true));
		a_Writer.EndElement();
		}

	if (GetPos() > 0)
		{
		wxString temp;
		temp.Printf("%ld", GetPos());
		a_Writer.StartElement("ResultPosition");
		a_Writer.AddValue(temp);
		a_Writer.EndElement();
		}


	if (GetFinished())
		a_Writer.StartElement("CompetitorStatus", "value=\"OK\"");
	else if (GetInvalid())
		a_Writer.StartElement("CompetitorStatus", "value=\"DidNotFinish\"");
	else
		a_Writer.StartElement("CompetitorStatus", "value=\"MisPunch\"");
	a_Writer.EndElement();

	for (int i = 0; i < m_Course->GetLegCount() -1; i++)
		{
		if (GetLegStat(i) && GetLegStat(i)->m_LegTime.GetSeconds() != 0)
			{
			wxString temp;
			temp.Printf("sequence=\"%d\"", i+1);
			a_Writer.StartElement("SplitTime", temp);

			a_Writer.StartElement("ControlCode");
			temp.Printf("%ld",m_Course->GetLeg(i).GetEndCN());
			a_Writer.AddValue(temp);
			a_Writer.EndElement();

			a_Writer.StartElement("Time");
			a_Writer.AddValue(FormatTimeTaken(GetLegStat(i)->m_ElapsedTime));
			a_Writer.EndElement();

			a_Writer.EndElement(); //SplitTime
			}
		}

	a_Writer.EndElement(); // Result

	a_Writer.EndElement(); // PersonResult

	}

wxString CResult::PersonID()
	{
	wxString result;
	result.Printf("%ld-%ld", GetSINumber(), GetRawIndex());
	return result;
	}

wxString CResult::ClubID()
	{
	if (m_Club.IsEmpty())
		return "None";
	else
		return m_Club;
	}
